#!/usr/bin/env python3
# import subprocess

# url = "https://docs.google.com/document/d/1S8VUpniVF_eH0olrhNoWUxbq5Ufm1Z3kv2EHAKaBM4w/edit?tab=t.0#bookmark=id.ibol8f34xyta"
# subprocess.run(["cmd.exe", "/c", "start", url])

import sys
import sqlite3
import os
from enum import Enum

class Signal(Enum):
    NONE = 0
    ADD = 1
    DELETE = 2
    LIST = 3
    GOTO = 4

arg_flag = "0"
arg_params = []
prg_root = os.path.dirname(os.path.abspath(__file__))
database_name = os.path.join(prg_root, "database", "ngator.db")
broadcast = Signal.NONE

# --------------------------------------------------------------------------

# Funciton definitions
def add_path(path, alias):
    # print(f"add: path:{path} alias:{alias}")
    global broadcast 
    broadcast = Signal.ADD
    with sqlite3.connect(database_name) as conn:
        cursor = conn.cursor()
        cursor.execute(
            "INSERT INTO paths (path, alias) VALUES (?, ?)",
                (path, alias)
        )
        conn.commit()
    return f"successfull[add]: [ {alias} ] = {path}"

def add_cwd_path(alias):
    global broadcast 
    broadcast = Signal.ADD
    path = sys.argv[1]
    with sqlite3.connect(database_name) as conn:
        cursor = conn.cursor()
        cursor.execute(
            "INSERT INTO paths (path, alias) VALUES (?, ?)",
                (path, alias)
        )
        conn.commit()
    return f"successfull[add]: [ {alias} ] = {path}"

def delete_path(alias):
    # print("delpath")
    global broadcast 
    broadcast = Signal.DELETE
    with sqlite3.connect(database_name) as conn:
        cursor = conn.cursor()
        cursor.execute(
            "DELETE FROM paths WHERE alias = ?",
            (alias,)
        )
        conn.commit()
    return f"successfull[remove]: [ {alias} ]"

def list_paths():
    # print("lspath")
    query_collector = ""
    global broadcast
    broadcast = Signal.LIST
    # print("lsing")
    with sqlite3.connect(database_name) as conn:
        cursor = conn.cursor()
        cursor.execute(
            "SELECT * FROM paths"
        )

        for row in cursor.fetchall():
            # print(row, file=sys.stderr)
            # get_collector+=f"{row}\n"
            alias = row[1]
            path = row[3]
            query_collector+=f"[ {alias} ] = {path}\n"
            # print(row)
        return query_collector

def goto_path(alias):
    global broadcast
    broadcast = Signal.GOTO
    # print("@@@ gotofunciton @@")
    # print(f"## {alias} ##")
    with sqlite3.connect(database_name) as conn:
        cursor = conn.cursor()
        cursor.execute(
            "SELECT path FROM paths WHERE alias = ?", (alias,)
        )
        query_out = cursor.fetchone()
        # print(f"(${query_out})")
        if query_out:
            # a match was found
            snached_path = query_out[0]
            return snached_path
        else:
            print(f"No path found for alias:: {alias}")

def get_all_alias():
    with sqlite3.connect(database_name) as conn:
        cursor = conn.cursor()
        cursor.execute(
            "SELECT alias FROM paths"
        )
        all_alias = cursor.fetchall()
        # remove tuples
        flattened = []
        for row in all_alias:
            flattened.append(row[0])

        # prep data as a string
        s_all_alias = ' '.join(flattened)

        # send data to stderr channel
        print(s_all_alias, file=sys.stderr)

def to_stdout(path):
    # send the path to stdout
    print(path)

def parse_args():
    global arg_flag, arg_params

    noflag_cmd = False
    if len(sys.argv) > 1:
        for f in Flags:
            if f.value == sys.argv[2]:
                noflag_cmd = True
                arg_flag = f
                arg_params = sys.argv[3:]
                break;
    if len(sys.argv) == 3 and not noflag_cmd:
        arg_flag = Flags.NOFLAG
        arg_params = sys.argv[2:]


# parse_args()
# print(arg_flag)
# print(arg_params)


# --------------------------------------------------------------------------

# --------------------------------------------------------------------------
# global variables

class Flags(Enum):
    ADD = "-a"
    ADD_CURRENT = '-ac'
    DELETE = "-d"
    LIST = "ls"
    NOFLAG = "0"


# dictionary of actions
actions = {
    Flags.ADD: add_path,
    Flags.ADD_CURRENT: add_cwd_path,
    Flags.DELETE: delete_path,
    Flags.LIST: list_paths,
    Flags.NOFLAG: goto_path
}

# --------------------------------------------------------------------------

# --------------------------------------------------------------------------
# Utility 

def action(actn_flag: Flags):
    global arg_flag, arg_params
    # print(f"FLAG: {arg_flag}")
    # print(f":: {arg_params}")
    if actn_flag in actions:
        func = actions[actn_flag]
        if len(arg_params) != func.__code__.co_argcount:
            return print(f"Error: {actn_flag} expects {func.__code__.co_argcount} arguments")
        else:
            return actions[actn_flag](*arg_params)

# --------------------------------------------------------------------------

# set flag based on input
parse_args()
# perform action based on flag
out = action(arg_flag)
# send message through stdout to parent shell code
to_stdout(out)
if broadcast == Signal.NONE:
    print(sys.argv)

# sent alias through err
get_all_alias()

# send request through exit code to parent shell code
sys.exit(broadcast.value)
